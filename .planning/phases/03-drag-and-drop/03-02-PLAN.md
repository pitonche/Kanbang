---
phase: 03-drag-and-drop
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/Board.tsx
  - src/components/Column.tsx
  - src/components/TaskCard.tsx
autonomous: true

must_haves:
  truths:
    - "User can drag a task card from one column and drop it into another column, and the task stays in the new column"
    - "Moving a task to the Done column automatically sets its completedAt timestamp"
    - "Drag interaction is smooth with no visible snap-back or flicker after dropping"
    - "Clicking a task card still opens the edit modal (not interpreted as drag)"
    - "User can drop a task into an empty column"
  artifacts:
    - path: "src/components/Board.tsx"
      provides: "DndContext wrapper, drag event handlers, DragOverlay, optimistic update"
      contains: "DndContext"
    - path: "src/components/Column.tsx"
      provides: "Droppable column with SortableContext"
      contains: "useDroppable"
    - path: "src/components/TaskCard.tsx"
      provides: "Sortable task card with drag transform"
      contains: "useSortable"
  key_links:
    - from: "src/components/Board.tsx"
      to: "convex/tasks.ts"
      via: "useMutation(api.tasks.moveToColumn).withOptimisticUpdate"
      pattern: "moveToColumn.*withOptimisticUpdate"
    - from: "src/components/Board.tsx"
      to: "src/components/TaskCardOverlay.tsx"
      via: "DragOverlay renders TaskCardOverlay"
      pattern: "TaskCardOverlay"
    - from: "src/components/Column.tsx"
      to: "@dnd-kit/core"
      via: "useDroppable for empty column drop target"
      pattern: "useDroppable"
    - from: "src/components/TaskCard.tsx"
      to: "@dnd-kit/sortable"
      via: "useSortable for drag source and drop target"
      pattern: "useSortable"
---

<objective>
Wire dnd-kit into the existing Board, Column, and TaskCard components to enable cross-column drag-and-drop with Convex optimistic updates.

Purpose: This is the core drag-and-drop integration -- the user can grab a task card, drag it to any column (including empty ones), and drop it. The optimistic update ensures no snap-back flicker by patching the local Convex cache synchronously.
Output: Fully functional drag-and-drop between all 6 columns with smooth visual feedback.
</objective>

<execution_context>
@/Users/ciciban/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ciciban/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-drag-and-drop/03-01-SUMMARY.md

@src/components/Board.tsx
@src/components/Column.tsx
@src/components/TaskCard.tsx
@src/components/TaskCardOverlay.tsx
@convex/tasks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DndContext, DragOverlay, and optimistic moveToColumn to Board.tsx</name>
  <files>src/components/Board.tsx</files>
  <action>
Modify `src/components/Board.tsx` to wrap the column layout in a DndContext and handle all drag events centrally.

**New imports to add:**
```typescript
import { DndContext, DragOverlay, closestCorners, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';
import type { DragStartEvent, DragEndEvent } from '@dnd-kit/core';
import { useMutation } from "convex/react";
import { TaskCardOverlay } from "./TaskCardOverlay";
```

**New state:**
- `activeTask: Doc<"tasks"> | null` -- the task currently being dragged (for DragOverlay rendering)

**Sensors:**
- `useSensors(useSensor(PointerSensor, { activationConstraint: { distance: 8 } }))` -- requires 8px movement before drag starts, preventing click-vs-drag conflict

**Mutation with optimistic update:**
```typescript
const moveToColumn = useMutation(api.tasks.moveToColumn).withOptimisticUpdate(
  (localStore, args) => {
    const currentTasks = localStore.getQuery(api.tasks.list, {});
    if (currentTasks === undefined) return;
    const now = Date.now();
    const updatedTasks = currentTasks.map((task) => {
      if (task._id !== args.id) return task;
      return {
        ...task,
        column: args.column,
        updatedAt: now,
        ...(args.column === "done" ? { completedAt: now } : { completedAt: undefined }),
      };
    });
    localStore.setQuery(api.tasks.list, {}, updatedTasks);
  }
);
```

**Event handlers:**
- `handleDragStart(event: DragStartEvent)`: Find the task by `event.active.id` from typedTasks, set as activeTask
- `handleDragEnd(event: DragEndEvent)`:
  1. Clear activeTask to null
  2. If no `event.over`, return (dropped outside any target)
  3. Find the dragged task from typedTasks by `event.active.id`
  4. Determine target column: if `over.id` matches a column ID from COLUMNS, use it directly (dropped on empty column droppable). Otherwise, find the task with `_id === over.id` and use its column.
  5. If task's current column differs from target column, call `moveToColumn({ id: taskId, column: targetColumn })`

**JSX changes:**
- Wrap the existing `{COLUMNS.map(...)}` in `<DndContext sensors={sensors} collisionDetection={closestCorners} onDragStart={handleDragStart} onDragEnd={handleDragEnd}>`
- Add `<DragOverlay>{activeTask ? <TaskCardOverlay task={activeTask} /> : null}</DragOverlay>` as the last child inside DndContext
- Keep the existing `<TaskModal>` OUTSIDE the DndContext (it's a dialog, not part of drag)

**Important:** The `<div className="flex gap-4 ...">` that wraps columns should be INSIDE the DndContext. The DndContext needs to be the ancestor of all droppable/sortable elements.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors.
  </verify>
  <done>Board.tsx has DndContext wrapping columns, PointerSensor with distance:8, handleDragStart/End, optimistic moveToColumn, and DragOverlay with TaskCardOverlay.</done>
</task>

<task type="auto">
  <name>Task 2: Add useDroppable and SortableContext to Column.tsx</name>
  <files>src/components/Column.tsx</files>
  <action>
Modify `src/components/Column.tsx` to make each column a droppable target with sortable task list.

**New imports:**
```typescript
import { useDroppable } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
```

**Changes to Column component:**

1. Add `useDroppable({ id })` hook at the top of the component (uses the column's `id` prop, e.g., "inbox", "backlog"):
   ```typescript
   const { setNodeRef } = useDroppable({ id });
   ```

2. Compute task IDs for SortableContext:
   ```typescript
   const taskIds = tasks.map(t => t._id);
   ```

3. Attach `ref={setNodeRef}` to the inner task container div (the one with `className="flex-1 p-2 min-h-[200px]"`). This makes the column itself a valid drop target, which is critical for empty columns.

4. Wrap the task list (both the empty state and the task.map) inside `<SortableContext items={taskIds} strategy={verticalListSortingStrategy}>`. The empty state text can remain inside the SortableContext -- it's just a visual fallback.

5. The Column interface already has `id: string` -- this is now used by useDroppable. Remove the destructuring that previously omitted `id` (the current signature is `{ label, tasks, onTaskClick }`) and include `id` in the destructured props.

**Result structure:**
```tsx
<div className="flex flex-col w-72 shrink-0 rounded-lg bg-column-bg">
  <h2>...</h2>
  <div ref={setNodeRef} className="flex-1 p-2 min-h-[200px]">
    <SortableContext items={taskIds} strategy={verticalListSortingStrategy}>
      {tasks.length === 0 ? <p>No tasks yet</p> : tasks.map(...)}
    </SortableContext>
  </div>
</div>
```
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors.
  </verify>
  <done>Column.tsx uses useDroppable with column id and wraps tasks in SortableContext with verticalListSortingStrategy.</done>
</task>

<task type="auto">
  <name>Task 3: Add useSortable to TaskCard.tsx for drag interaction</name>
  <files>src/components/TaskCard.tsx</files>
  <action>
Modify `src/components/TaskCard.tsx` to make each task card both a drag source and a drop target using useSortable.

**New imports:**
```typescript
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
```

**Changes to TaskCard component:**

1. Add `useSortable({ id: task._id })` hook:
   ```typescript
   const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({
     id: task._id,
   });
   ```

2. Create a style object for drag transforms:
   ```typescript
   const style = {
     transform: CSS.Transform.toString(transform),
     transition,
     opacity: isDragging ? 0.5 : 1,
   };
   ```

3. Update the outer div to use the sortable ref and attributes:
   - Add `ref={setNodeRef}` to the div
   - Add `style={style}` to the div
   - Spread `{...attributes}` and `{...listeners}` on the div
   - Keep the existing `onClick` handler -- dnd-kit's PointerSensor with distance:8 ensures clicks still fire normally when pointer doesn't move 8px

4. The existing className stays the same. Just add the new props to the div element:
   ```tsx
   <div
     ref={setNodeRef}
     style={style}
     {...attributes}
     {...listeners}
     className={`bg-card-bg border border-card-border rounded-md p-3 mb-2 border-l-4 cursor-pointer hover:shadow-sm transition-shadow ${priorityBorder[task.priority]}`}
     onClick={() => onClick(task._id)}
   >
   ```

**Important:** The `cursor-pointer` class is already on the card. When dragging, dnd-kit takes over cursor handling via the sensor, so no additional cursor changes needed.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Then run `bun run build` to confirm production build succeeds.
  </verify>
  <done>TaskCard.tsx uses useSortable with task._id, applies CSS transform/transition/opacity during drag, and preserves click handler for modal.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `bun run build` produces a successful production build
3. Board.tsx: DndContext wraps columns, closestCorners collision detection, PointerSensor with distance:8
4. Board.tsx: moveToColumn uses .withOptimisticUpdate() that patches localStore with column + completedAt logic
5. Board.tsx: DragOverlay renders TaskCardOverlay for the active task
6. Column.tsx: useDroppable with column id, SortableContext wrapping tasks
7. TaskCard.tsx: useSortable with task._id, CSS.Transform applied, isDragging opacity
8. Drag a task between columns -- it stays in the new column (no snap-back)
9. Drag a task to Done -- completedAt is set
10. Click a task card without moving mouse 8px -- modal opens (not a drag)
</verification>

<success_criteria>
- User can drag task cards between all 6 columns
- Tasks stay in their new column after drop (optimistic update prevents snap-back)
- Moving to Done sets completedAt, moving out of Done clears it
- Clicking cards still opens the edit modal
- Empty columns accept drops
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-drag-and-drop/03-02-SUMMARY.md`
</output>
